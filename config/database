const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs').promises;

class Database {
    constructor() {
        this.db = null;
        this.dataDir = path.join(__dirname, '..', 'data');
        this.dbPath = path.join(this.dataDir, 'database.sqlite');
    }

    async initialize() {
        try {
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ data Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
            await fs.mkdir(this.dataDir, { recursive: true });
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            this.db = new sqlite3.Database(this.dbPath, (err) => {
                if (err) {
                    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', err.message);
                    throw err;
                }
                console.log(`âœ… ØªÙ… ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­: ${this.dbPath}`);
            });

            // ØªØ¹Ø±ÙŠÙ Ø¯ÙˆØ§Ù„ ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
            this.run = function(sql, params = []) {
                return new Promise((resolve, reject) => {
                    this.db.run(sql, params, function(err) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve({ lastID: this.lastID, changes: this.changes });
                        }
                    });
                });
            };

            this.get = function(sql, params = []) {
                return new Promise((resolve, reject) => {
                    this.db.get(sql, params, (err, row) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(row);
                        }
                    });
                });
            };

            this.all = function(sql, params = []) {
                return new Promise((resolve, reject) => {
                    this.db.all(sql, params, (err, rows) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(rows);
                        }
                    });
                });
            };

            // ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
            this.exec = function(sql) {
                return new Promise((resolve, reject) => {
                    this.db.exec(sql, (err) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve();
                        }
                    });
                });
            };

            return this.db;
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', error.message);
            throw error;
        }
    }

    async close() {
        return new Promise((resolve, reject) => {
            if (this.db) {
                this.db.close((err) => {
                    if (err) {
                        reject(err);
                    } else {
                        console.log('âœ… ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                        resolve();
                    }
                });
            } else {
                resolve();
            }
        });
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    async backup(backupDir) {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupFile = path.join(backupDir, `backup_${timestamp}.sqlite`);
            
            await fs.copyFile(this.dbPath, backupFile);
            console.log(`ğŸ’¾ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: ${backupFile}`);
            
            return backupFile;
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ:', error.message);
            throw error;
        }
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
    async restore(backupFile) {
        try {
            await fs.copyFile(backupFile, this.dbPath);
            console.log(`ğŸ”„ ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: ${backupFile}`);
            return true;
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©:', error.message);
            throw error;
        }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    async optimize() {
        try {
            await this.run('VACUUM');
            await this.run('ANALYZE');
            console.log('âœ¨ ØªÙ… ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
            return true;
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', error.message);
            throw error;
        }
    }

    // Ø¯Ø§Ù„Ø© Ù„ÙØ­Øµ ØµØ­Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    async healthCheck() {
        try {
            const result = await this.get('SELECT 1 as status');
            return result && result.status === 1;
        } catch (error) {
            console.error('âŒ ÙØ­Øµ ØµØ­Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙØ´Ù„:', error.message);
            return false;
        }
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    async getStats() {
        try {
            const tables = await this.all(`
                SELECT 
                    name,
                    (SELECT COUNT(*) FROM sqlite_master WHERE type='table') as table_count,
                    (SELECT COUNT(*) FROM sqlite_master WHERE type='index') as index_count
                FROM sqlite_master 
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
            `);

            const tableStats = [];
            for (const table of tables) {
                const countResult = await this.get(`SELECT COUNT(*) as count FROM ${table.name}`);
                tableStats.push({
                    name: table.name,
                    row_count: countResult.count
                });
            }

            return {
                tables: tableStats,
                total_tables: tables.length,
                total_rows: tableStats.reduce((sum, table) => sum + table.row_count, 0)
            };
        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', error.message);
            return null;
        }
    }
}

module.exports = new Database();
